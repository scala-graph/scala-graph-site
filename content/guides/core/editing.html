---
title: Core User Guide
sideMenuItems: >
<li><a href="/guides/core/contents.html">Contents</a></li>
<li><a href="/guides/core/concepts.html">Key Concepts</a></li>
<li><a href="/guides/core/planning.html">Plan Your Graph</a></li>
<li><a>Edit Your Graph</a></li>
<li><a href="/guides/core/inspecting.html">Inspect Your Graph</a></li>
<li><a href="/guides/core/traversing.html">Traverse Your Graph</a></li>
<li><a href="/guides/core/mapping.html">Map Your Graph</a></li>
<li><a href="/guides/core/enriching.html">Enrich Your Graph</a></li>
<li><a href="/guides/core/characteristics.html">Run-time Characteristics</a></li>
---
<h1>Core User Guide: Edit Your Graph</h1>

<p> After the planning phase you are now sure about what type of nodes and edges to be employed.
    Here you will learn how to roll out and populate your graph.
</p>

<h2>Choose the Type Parameters</h2>
<pre class="prettyprint lang-scala nolinenum">trait Graph[N, E <: Edge[N]]
</pre>
<p><code>N&nbsp;</code> type of the nodes like a concrete <code>class</code>, a <code>trait</code> or an ADT.
</p>
<p><code>E&nbsp;</code> type of the edges like a concrete <code>class</code>, a <code>trait</code> or an ADT.
</p>
<p> The node type is unconstrained. Normally you will opt for immutable nodes but, in rare cases, mutable nodes might
    make sense. When using mutable nodes, beware that only fields that are not used by the class'
    <code>equals</code>/<code>hashCode</code> may be mutated.
    This is because the behavior of hash-based collections is not specified if the value of a field is changed
    such that <code>equals</code>/<code>hashCode</code> are affected - see also
    <a href="http://download.oracle.com/javase/1.4.2/docs/api/java/util/Map.html">java.util.Map</a>.
</p>
<p> To get the appropriate edge type, look up your use case in the following decision tables. We use the term
</p>
<ul>
    <li><i>simple graph</i> for non-multigraphs</li>
    <li><i>weighted edge</i> for edges with a single label of type <code>Double</code>.
        Note that, in general, edges always have a default weight of <code>1</code> and
        you can also define a specific weight function for any custom edge.
    </li>
    <li><i>ordered hyperedge</i> for hyperedges that are treated equal
        only if they have the same ends in the same order.
        In contrast, unordered hyperedges have a bag semantic with respect to their ends.
    </li>
    <li><i>ordered directed hyperedge</i> for directed hyperedges that are treated equal
        only if they have the same sources and targets in the same order.
        In contrast, unordered directed hyperedges have a bag semantic with respect to their sources and targets.
    </li>
</ul>
<table>
    <caption>Table: Generic non-labeled edges.</caption>
    <tr>
        <td><strong>Type of graph</strong></td>
        <td><strong>import scalax.collections...</strong></td>
        <td><strong>Edge type</strong></td>
    </tr>
    <tr>
        <td>simple directed or undirected graph</td>
        <td><code>edges._</code></td>
        <td><code>DiEdge</code> or <code>UnDiEdge</code></td>
    </tr>
    <tr>
        <td>simple directed or undirected hypergraph</td>
        <td><code>hyperedges._</code></td>
        <td><code>DiHyperEdge</code> or <code>HyperEdge</code></td>
    </tr>
</table>
<table>
    <caption>Table: Weighted edges.</caption>
    <tr>
        <td><strong>Type of graph</strong></td>
        <td><strong>import scalax.collections...</strong></td>
        <td><strong>Edge type</strong></td>
    </tr>
    <tr>
        <td>simple directed or undirected graph</td>
        <td><code>edges.labeled._</code></td>
        <td><code>WDiEdge</code> or <code>WUnDiEdge</code></td>
    </tr>
    <tr>
        <td>directed or undirected multigraph</td>
        <td><code>edges.multilabeled._</code></td>
        <td><code>WDiEdge</code> or <code>WUnDiEdge</code></td>
    </tr>
    <tr>
        <td>simple directed or undirected hypergraph</td>
        <td><code>hyperedges.labeled._</code></td>
        <td>derive custom edge from <code>LDiHyperEdge</code> or <code>LDiHyperEdge</code>,<br/>
            override <code>def weight</code>
        </td>
    </tr>
    <tr>
        <td>directed or undirected multi hypergraph</td>
        <td><code>hyperedges.multilabeled._</code>,<br/>
            <code>generic.ExtendedKeyByWeight</code> or<br/>
            <code>generic.MultiEdge</code>
        </td>
        <td>derive custom edge from <code>LDiHyperEdge</code> or <code>LDiHyperEdge</code>,<br/>
            <code>override def weight</code>,<br/>
            if you need to add only <code>weight</code> to define eqauality mix in <code>ExtendedKeyByWeight</code>,
            otherweise mix in <code>MultiEdge</code>
        </td>
    </tr>
</table>
<table>
    <caption>Table: Generic labeled edges with a single label field.</caption>
    <tr>
        <td><strong>Type of graph</strong></td>
        <td><strong>import scalax.collections...</strong></td>
        <td><strong>Edge type</strong></td>
    </tr>
    <tr>
        <td>simple directed or undirected graph</td>
        <td><code>edges.labeled._</code></td>
        <td>derive custom edge from <code>LDiEdge</code> or <code>LUnDiEdge</code></td>
    </tr>
    <tr>
        <td>directed or undirected multigraph</td>
        <td><code>edges.multilabeled._</code></td>
        <td>derive custom edge from <code>LDiEdge</code> or <code>LUnDiEdge</code>,<br/>
            implement <code>def extendKeyBy</code>
        </td>
    </tr>
    <tr>
        <td>simple directed or undirected hypergraph</td>
        <td><code>hyperedges.labeled._</code></td>
        <td>derive custom edge from <code>LDiHyperEdge</code> or <code>LHyperEdge</code></td>
    </tr>
    <tr>
        <td>simple directed or undirected hypergraph with ordered hyperedges</td>
        <td><code>hyperedges.ordered.labeled._</code></td>
        <td>derive custom edge from <code>LDiHyperEdge</code> or <code>LHyperEdge</code></td>
    </tr>
    <tr>
        <td>directed or undirected multi hypergraph</td>
        <td><code>hyperedges.multilabeled._</code></td>
        <td>derive custom edge from <code>LDiHyperEdge</code> or <code>LHyperEdge</code>,<br/>
            implement <code>def extendKeyBy</code>
        </td>
    </tr>
    <tr>
        <td>directed or undirected multi hypergraph with ordered hyperedges</td>
        <td><code>hyperedges.ordered.multilabeled._</code></td>
        <td>derive custom edge from <code>LDiHyperEdge</code> or <code>LHyperEdge</code>,<br/>
            implement <code>def extendKeyBy</code>
        </td>
    </tr>
</table>
<table>
    <caption>Table: Custom edges with any number and type of labels.</caption>
    <tr>
        <td><strong>Type of graph</strong></td>
        <td><strong>import scalax.collections...</strong></td>
        <td><strong>Edge type</strong></td>
    </tr>
    <tr>
        <td>simple directed labeled graph</td>
        <td><code>generic.AbstractDiEdge</code></td>
        <td>derive custom edge from <code>AbstractDiEdge</code></td>
    </tr>
    <tr>
        <td>simple undirected labeled graph</td>
        <td><code>generic.AbstractUnDiEdge</code></td>
        <td>derive custom edge from <code>AbstractUnDiEdge</code></td>
    </tr>
    <tr>
        <td>directed labeled multigraph</td>
        <td><code>generic.AbstractDiEdge</code>,<br/>
            <code>generic.MultiEdge</code>
        </td>
        <td>derive custom edge from <code>AbstractDiEdge</code>,<br/>
            mix in <code>MultiEdge</code>
        </td>
    </tr>
    <tr>
        <td>undirected labeled multigraph</td>
        <td><code>generic.AbstractUnDiEdge</code>,<br/>
            <code>generic.MultiEdge</code>
        </td>
        <td>derive custom edge from <code>AbstractUnDiEdge</code>,<br/>
            mix in <code>MultiEdge</code>
        </td>
    </tr>
    <tr>
        <td>simple directed labeled hypergraph</td>
        <td><code>generic.AbstractDiHyperEdge</code></td>
        <td>derive custom edge from <code>AbstractDiHyperEdge</code></td>
    </tr>
    <tr>
        <td>simple undirected labeled hypergraph</td>
        <td><code>generic.AbstractHyperEdge</code></td>
        <td>derive custom edge from <code>AbstractHyperEdge</code></td>
    </tr>
    <tr>
        <td>directed labeled multi hypergraph</td>
        <td><code>generic.AbstractDiHyperEdge</code>,<br/>
            <code>generic.MultiEdge</code>
        </td>
        <td>derive custom edge from <code>AbstractDiHyperEdge</code>,<br/>
            mix in <code>MultiEdge</code>
        </td>
    </tr>
    <tr>
        <td>undirected labeled multi hypergraph</td>
        <td><code>generic.AbstractHyperEdge</code>,<br/>
            <code>generic.MultiEdge</code>
        </td>
        <td>derive custom edge from <code>AbstractHyperEdge</code>,<br/>
            mix in <code>MultiEdge</code>
        </td>
    </tr>
</table>
<p> Often your graph contains directed and also undirected edges/hyperedges.
    To denote such a mixed graph, refer to the <code>trait</code>s prefixed by <code>Any</code>.
    Once you have chosen your mixed edge types you will need to define their common ancestor
    in terms of these <code>Any*</code> traits:
</p>
<ul>
    <li>If your graph has generic edges, annotate its type like <code>Graph[MyNode, AnyEdge[MyNode]]</code>.</li>
    <li>If you go with an ADT of edges, let the base trait of your ADT extend the appropriate trait
        like <code>sealed trait MyEdge extends AnyEdge[MyNode]</code>.
    </li>
</ul>
<table>
    <caption>Table: Traits to annotate mixed graphs.</caption>
    <tr>
        <td><strong>Graph contains</strong></td>
        <td><strong>Edge type in scalax.collections...</strong></td>
    </tr>
    <tr>
        <td>directed and undirected edges</td>
        <td><code>generic.AnyEdge</code></td>
    </tr>
    <tr>
        <td>directed edges and hyperedges</td>
        <td><code>generic.AnyDiHyperEdge</code></td>
    </tr>
    <tr>
        <td>directed and undirected edges and hyperedges</td>
        <td><code>generic.AnyHyperEdge</code></td>
    </tr>
</table>

<h2 id="CustomEdges">Touch Up your Custom Edge</h2>


<h3 id="HyperedgeEndpoints">Hyperedge equality</h3>
<p> Looking at the endpoints of a hyperedge respectively the sources or targets of
    a directed hyperedge, equality is even more weird. For instance, would you say that
    <code>HyperEdge(1, 2, 2)</code> is equal to <code>HyperEdge(2, 2, 1)</code> or not?
    It turns out that depending on the use case both propositions may be desirable to hold.
</p>
<p><em id="G4S">Graph for Scala</em> currently supports two kinds of endpoint collections:
    <code>Bag</code> and <code>Sequence</code>. With <code>Bag</code> being the default kind,
    the above hyperedges are in fact equal. The endpoint collection kind is controlled
    by an implicit value of the type <code>CollectionKind</code>.
    Define <code>Sequence</code> as an implicit value to turn this kind on:
</p>
<pre class="prettyprint lang-scala nolinenum">import scalax.collection.GraphEdge._
implicit val kind: CollectionKind = Sequence
HyperEdge(1, 2, 2) == HyperEdge(2, 2, 1) // false 
</pre>

<h3 id="EdgesCreationMethods">Bypassing edge factories</h3>
<p> What is more, mutable <code>Graph</code> instances provide edge creation methods
    to be called directly on <code>Graph</code> instances (<code>addEdge</code>,
    <code>+~=</code>, <code>addAndGetEdge</code>) or on inner nodes
    (<code>connectWith</code>, <code>+~</code>). These methods should save execution
    time since less conversion is necessary to complete edge creation.
</p>

<h2>Instantiating Graphs</h2>
<pre class="prettyprint lang-scala linenums">val g1 = Graph(3~1, 5)            // Graph[Int,UnDiEdge](1, 3, 5, 3~1)
val g2 = Graph(UnDiEdge(3, 1), 5) // same as above
val gA = Graph(3~>1.2)            // Graph[AnyVal,DiEdge](3, 1.2, 3~>1.2)
val h = Graph(1~1, 1~2~3)         // Graph[Int,HyperEdge](1, 2, 3, 1~1, 1~2~3)
val (jfc, fra, dme) = (Airport("JFC"), Airport("FRA"), Airport("DME"))
val flights = Graph(
	(jfc ~+#> fra)(Flight("LH 400" ,10 o 25, 8 h 20)),
	(fra ~+#> dme)(Flight("LH 1444", 7 o 50, 3 h 10))
val nodes = List(5)
val edges = List(3~1)
val g3 = Graph.from(nodes, edges)
var n, m = 0; val f = Graph.fill(100)( {n = m; m += 1; n~m} ) 
</pre>
<p>As to</p>
<ol>
    <li>Creates an undirected graph of the type <code>Graph[Int,UnDiEdge]
    </code>with the node set <code>{1, 3, 5}</code> and the edge set {3~1}.
        The operator <code>~</code> is used to create undirected edges.
        N is inferred to be <code>Int</code> because both the edge ends
        and the single node are of type <code>Int</code>.
    </li>
    <li>Creates the very same undirected graph as a). Operator <code>~</code>
        is just a short-hand for invoking the factory <code>UnDiEdge</code>.
    </li>
    <li>Creates a directed graph of the type <code>Graph[AnyVal,DiEdge]</code>
        with the node set <code>{3, 1.2}</code> and the edge set {3~&gt;1.2}.
        The operator <code>~&gt;</code> is used to create directed edges.
        N is inferred to be <code>AnyVal</code> because this is the smallest common
        super type of the edge ends.
    </li>
    <li>Creates a hypergraph of the type <code>Graph[Int,HyperEdge]
    </code>with the node set <code>{1, 2, 3}</code> and the edge set {1~1, 1~2~3}.
        In <code>1~2~3</code> the second <code>~</code> operator creates
        an undirected hyperedge because the left operand is already an edge.
    </li>
    <li value="6">Creates an instance of<code> Graph[Airport,LkDiEdge]</code>
        with a node set containing the airports <code>JFC</code>, <code>FRA</code>
        and <code>DME</code> derived from the edge ends and an edge set
        containing two flights. The edges have labels of the type <code>Flight</code>,
        <code>~+#&gt;</code> is an edge factory shortcut to pass the labels.
        The <code>Flight</code> attributes are flight number, departure time
        and flight duration. See also <em>2.3 Edge Factories</em>.
    </li>
    <li value="11">Creates a <code>Graph</code> from the <code>Iterable</code>
        values <code>nodes</code> and <code>edges</code>. This <code>Graph</code>
        instance&nbsp; <code>g3</code> equals to <code>g1</code>.
    </li>
    <li>Creates a <code>Graph</code> instance with 100 edges {0~1, 1~2, ..., 99~100}.
    </li>
</ol>

<h2>Type Parameter Inference</h2>
<pre class="prettyprint lang-scala linenums">val g = Graph()                // Graph[Nothing,Nothing]
val g = Graph(1)               // Graph[Int,Nothing]
val g = Graph(1~>2); g += 1.2  // Graph[Int,DiEdge]; compiler error
Graph(1~>2) + 2~3              // compiler error
</pre>
<p> Calling the default <code>Graph</code> factory without type parameters is in general
    satisfactory if at least one edge is passed. Otherwise, analogously to regular Scala
    collection members, you are advised to explicitly define the type parameters:
</p>
<p>As to</p>
<ol>
    <li>In absence of any arguments, <code>Nothing</code> is inferred for both the node
        and the edge type so you cannot add any nodes or edges to this instance later on.
    </li>
    <li>In absence of any edge arguments, <code>Nothing</code> is inferred for the
        edge type so you can add only nodes to this instance later on.
    </li>
    <li>To be able to add a <code>Double</code> to this instance, you must define
        its type parameters broader at creation time like <code>Graph[AnyVal,DiEdge]</code>.
        Also note that, due to the higher kinded nature of the <code>E[X]</code>
        type parameter, <code>DiEdge</code> is correctly inferred &#8211;
        even if some of you would expect <code>DiEdge[Int]</code>.
    </li>
    <li>This addition is rejected by the compiler because <code>[Int,DiEdge]</code>
        is inferred and <code>2~3</code> is not a directed but an undirected
        edge. Directed edges inherit from undirected edges but the opposite is
        not true.
    </li>
</ol>
<p> As a final note, whenever you are implementing own functionality on top
    of <code>Graph</code>, the Scala type system requires to declaratively
    maintain type parameter bounds as shown in the following example:
</p>
<pre class="prettyprint lang-scala nolinenum">def myFunction[N, E[X] <: EdgeLikeIn[X]](g: Graph[N,E])
</pre>

<p> In most cases you need to import the following:</p>
<pre class="prettyprint lang-scala nolinenum">import scalax.collection.Graph // or scalax.collection.mutable.Graph
import scalax.collection.GraphPredef._, scalax.collection.GraphEdge._
</pre>

