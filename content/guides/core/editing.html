---
title: Core User Guide
sideMenuItems: >
<li><a href="/guides/core/contents.html">Contents</a></li>
<li><a href="/guides/core/concepts.html">Key Concepts</a></li>
<li><a href="/guides/core/planning.html">Plan Your Graph</a></li>
<li><a>Edit Your Graph</a></li>
<li><a href="/guides/core/inspecting.html">Inspect Your Graph</a></li>
<li><a href="/guides/core/traversing.html">Traverse Your Graph</a></li>
<li><a href="/guides/core/mapping.html">Map Your Graph</a></li>
<li><a href="/guides/core/enriching.html">Enrich Your Graph</a></li>
<li><a href="/guides/core/characteristics.html">Run-time Characteristics</a></li>
---
<h1>Core User Guide: Edit Your Graph</h1>

<p> After the planning phase you are now sure about what type of nodes and edges to be employed.
    Here you will learn how to roll out and populate your graph.
</p>

<h2>Choose the Type Parameters</h2>
<pre class="prettyprint lang-scala nolinenum">trait Graph[N, E <: Edge[N]]
</pre>
<p><code>N&nbsp;</code> type of the nodes like a concrete <code>class</code>, a <code>trait</code> or an ADT.
</p>
<p><code>E&nbsp;</code> type of the edges like a concrete <code>class</code>, a <code>trait</code> or an ADT.
</p>
<p> The node type is unconstrained. Normally you will opt for immutable nodes but sometimes mutable nodes might
    make sense. When using mutable nodes, beware that only fields that are not used by the class'
    <code>equals</code>/<code>hashCode</code> may be mutated.
    Otherwise, you would be posed to observe issues on adding or looking up nodes.
    This is because the behaviour of hash-based collections is not specified if the value of a field is changed
    such that <code>equals</code>/<code>hashCode</code> are affected - see also
    <a href="http://download.oracle.com/javase/1.4.2/docs/api/java/util/Map.html">java.util.Map</a>.
</p>
<p> To get the appropriate edge type, look up your use case in the following decision tables. We use the term
</p>
<ul>
    <li><i>simple graph</i> for non-multigraphs</li>
    <li><i>weighted edge</i> for edges with a single label of type <code>Double</code>.
        Note that, in general, edges always have a default weight of <code>1</code> and
        you can also define a specific weight function for any custom edge.
    </li>
    <li><i>ordered hyperedge</i> for hyperedges that are treated equal
        only if they have the same ends in the same order.
        In contrast, unordered hyperedges have a bag semantic with respect to their ends.
    </li>
    <li><i>ordered directed hyperedge</i> for directed hyperedges that are treated equal
        only if they have the same sources and targets in the same order.
        In contrast, unordered directed hyperedges have a bag semantic with respect to their sources and targets.
    </li>
</ul>
<table>
    <caption>Table: Generic non-labeled edges.</caption>
    <tr>
        <td><strong>Type of graph</strong></td>
        <td><strong>import scalax.collections...</strong></td>
        <td><strong>Edge type</strong></td>
    </tr>
    <tr>
        <td>simple directed or undirected graph</td>
        <td><code>edges._</code></td>
        <td><code>DiEdge</code> or <code>UnDiEdge</code></td>
    </tr>
    <tr>
        <td>simple directed or undirected hypergraph</td>
        <td><code>hyperedges._</code></td>
        <td><code>DiHyperEdge</code> or <code>HyperEdge</code></td>
    </tr>
</table>
<table>
    <caption>Table: Weighted edges.</caption>
    <tr>
        <td><strong>Type of graph</strong></td>
        <td><strong>import scalax.collections...</strong></td>
        <td><strong>Edge type</strong></td>
    </tr>
    <tr>
        <td>simple directed or undirected graph</td>
        <td><code>edges.labeled._</code></td>
        <td><code>WDiEdge</code> or <code>WUnDiEdge</code></td>
    </tr>
    <tr>
        <td>directed or undirected multigraph</td>
        <td><code>edges.multilabeled._</code></td>
        <td><code>WDiEdge</code> or <code>WUnDiEdge</code></td>
    </tr>
    <tr>
        <td>simple directed or undirected hypergraph</td>
        <td><code>hyperedges.labeled._</code></td>
        <td>derive custom edge from <code>LDiHyperEdge</code> or <code>LDiHyperEdge</code>,<br/>
            override <code>def weight</code>
        </td>
    </tr>
    <tr>
        <td>directed or undirected multi hypergraph</td>
        <td><code>hyperedges.multilabeled._</code>,<br/>
            <code>generic.ExtendedKeyByWeight</code> or<br/>
            <code>generic.MultiEdge</code>
        </td>
        <td>derive custom edge from <code>LDiHyperEdge</code> or <code>LDiHyperEdge</code>,<br/>
            <code>override def weight</code>,<br/>
            if you need to add only <code>weight</code> to define eqauality mix in <code>ExtendedKeyByWeight</code>,
            otherweise mix in <code>MultiEdge</code>
        </td>
    </tr>
</table>
<table>
    <caption>Table: Generic labeled edges with a single label field.</caption>
    <tr>
        <td><strong>Type of graph</strong></td>
        <td><strong>import scalax.collections...</strong></td>
        <td><strong>Edge type</strong></td>
    </tr>
    <tr>
        <td>simple directed or undirected graph</td>
        <td><code>edges.labeled._</code></td>
        <td>derive custom edge from <code>LDiEdge</code> or <code>LUnDiEdge</code></td>
    </tr>
    <tr>
        <td>directed or undirected multigraph</td>
        <td><code>edges.multilabeled._</code></td>
        <td>derive custom edge from <code>LDiEdge</code> or <code>LUnDiEdge</code>,<br/>
            implement <code>def extendKeyBy</code>
        </td>
    </tr>
    <tr>
        <td>simple directed or undirected hypergraph</td>
        <td><code>hyperedges.labeled._</code></td>
        <td>derive custom edge from <code>LDiHyperEdge</code> or <code>LHyperEdge</code></td>
    </tr>
    <tr>
        <td>simple directed or undirected hypergraph with ordered hyperedges</td>
        <td><code>hyperedges.ordered.labeled._</code></td>
        <td>derive custom edge from <code>LDiHyperEdge</code> or <code>LHyperEdge</code></td>
    </tr>
    <tr>
        <td>directed or undirected multi hypergraph</td>
        <td><code>hyperedges.multilabeled._</code></td>
        <td>derive custom edge from <code>LDiHyperEdge</code> or <code>LHyperEdge</code>,<br/>
            implement <code>def extendKeyBy</code>
        </td>
    </tr>
    <tr>
        <td>directed or undirected multi hypergraph with ordered hyperedges</td>
        <td><code>hyperedges.ordered.multilabeled._</code></td>
        <td>derive custom edge from <code>LDiHyperEdge</code> or <code>LHyperEdge</code>,<br/>
            implement <code>def extendKeyBy</code>
        </td>
    </tr>
</table>
<table>
    <caption>Table: Custom edges with any number and type of labels.</caption>
    <tr>
        <td><strong>Type of graph</strong></td>
        <td><strong>import scalax.collections...</strong></td>
        <td><strong>Edge type</strong></td>
    </tr>
    <tr>
        <td>simple directed labeled graph</td>
        <td><code>generic.AbstractDiEdge</code></td>
        <td>derive custom edge from <code>AbstractDiEdge</code></td>
    </tr>
    <tr>
        <td>simple undirected labeled graph</td>
        <td><code>generic.AbstractUnDiEdge</code></td>
        <td>derive custom edge from <code>AbstractUnDiEdge</code></td>
    </tr>
    <tr>
        <td>directed labeled multigraph</td>
        <td><code>generic.AbstractDiEdge</code>,<br/>
            <code>generic.MultiEdge</code>
        </td>
        <td>derive custom edge from <code>AbstractDiEdge</code>,<br/>
            mix in <code>MultiEdge</code>
        </td>
    </tr>
    <tr>
        <td>undirected labeled multigraph</td>
        <td><code>generic.AbstractUnDiEdge</code>,<br/>
            <code>generic.MultiEdge</code>
        </td>
        <td>derive custom edge from <code>AbstractUnDiEdge</code>,<br/>
            mix in <code>MultiEdge</code>
        </td>
    </tr>
    <tr>
        <td>simple directed labeled hypergraph</td>
        <td><code>generic.AbstractDiHyperEdge</code></td>
        <td>derive custom edge from <code>AbstractDiHyperEdge</code></td>
    </tr>
    <tr>
        <td>simple undirected labeled hypergraph</td>
        <td><code>generic.AbstractHyperEdge</code></td>
        <td>derive custom edge from <code>AbstractHyperEdge</code></td>
    </tr>
    <tr>
        <td>directed labeled multi hypergraph</td>
        <td><code>generic.AbstractDiHyperEdge</code>,<br/>
            <code>generic.MultiEdge</code>
        </td>
        <td>derive custom edge from <code>AbstractDiHyperEdge</code>,<br/>
            mix in <code>MultiEdge</code>
        </td>
    </tr>
    <tr>
        <td>undirected labeled multi hypergraph</td>
        <td><code>generic.AbstractHyperEdge</code>,<br/>
            <code>generic.MultiEdge</code>
        </td>
        <td>derive custom edge from <code>AbstractHyperEdge</code>,<br/>
            mix in <code>MultiEdge</code>
        </td>
    </tr>
</table>
<p> Often your graph contains directed and also undirected edges/hyperedges.
    To denote such a mixed graph, refer to the <code>trait</code>s prefixed by <code>Any</code>.
    Once you have chosen your mixed edge types you will need to define their common ancestor
    in terms of these <code>Any*</code> traits:
</p>
<ul>
    <li>If your graph has generic edges, annotate its type like <code>Graph[MyNode, AnyEdge[MyNode]]</code>.</li>
    <li>If you go with an ADT of edges, let the base trait of your ADT extend the appropriate trait
        like <code>sealed trait MyEdge extends AnyEdge[MyNode]</code>.
    </li>
</ul>
<table>
    <caption>Table: Traits to annotate mixed graphs.</caption>
    <tr>
        <td><strong>Graph contains</strong></td>
        <td><strong>Edge type in scalax.collections...</strong></td>
    </tr>
    <tr>
        <td>directed and undirected edges</td>
        <td><code>generic.AnyEdge</code></td>
    </tr>
    <tr>
        <td>directed edges and hyperedges</td>
        <td><code>generic.AnyDiHyperEdge</code></td>
    </tr>
    <tr>
        <td>directed and undirected edges and hyperedges</td>
        <td><code>generic.AnyHyperEdge</code></td>
    </tr>
</table>

<h2 id="CustomEdgeGoodies">Touch Up your Custom Edge</h2>
<p> It is in your hands to follow library conventions or stay with the simplest possible, Java-like implementation.
    We provide separate traits for every aspect of those conventions to facilitate a fine-grained selection.
</p>

<h3 id="InfixEdgeConstructors">Add Infix Edge Constructors</h3>
<p> Go for the syntactic sugar <code>~></code> and its companions if you like. As per library convention
</p>
<table>
    <tr>
        <td><strong>The infix constructor of</strong></td>
        <td><strong>Uses the node operator</strong></td>
        <td><strong>Like</strong></td>
    </tr>
    <tr>
        <td>directed edges</td>
        <td align="center"><code>~></code></td>
        <td><code>1 ~> 2</code></td>
    </tr>
    <tr>
        <td>undirected edges</td>
        <td align="center"><code>~</code></td>
        <td><code>1 ~ 2</code></td>
    </tr>
    <tr>
        <td>directed hyperedges</td>
        <td align="center"><code>~~></code></td>
        <td><code>more(1, -1) ~~> one(2)</code></td>
    </tr>
    <tr>
        <td>hyperedges</td>
        <td align="center"><code>~~</code></td>
        <td><code>1 ~~ -1 ~~ 2</code></td>
    </tr>
</table>
<p>and</p>
<table>
    <tr>
        <td><strong>The infix constructor of</strong></td>
        <td><strong>Uses the label operator</strong></td>
        <td><strong>Like</strong></td>
    </tr>
    <tr>
        <td>weighted edges</td>
        <td align="center"><code>%</code></td>
        <td><code>1 ~> 2 % 5.5</code></td>
    </tr>
    <tr>
        <td>weighted multiedges</td>
        <td align="center"><code>%%</code></td>
        <td><code>1 ~ 2 %% 5.5</code></td>
    </tr>
    <tr>
        <td>any other non-multi edge</td>
        <td align="center"><code>:+</code></td>
        <td><code>1 ~> 2 :+ labels</code></td>
    </tr>
    <tr>
        <td></td>
        <td></td>
        <td><code>more(1, -1) ~~> one(2) :+ labels</code></td>
    </tr>
    <tr>
        <td>any other multiedge</td>
        <td align="center"><code>:++</code></td>
        <td><code>1 ~ 2 :++ labels</code></td>
    </tr>
    <tr>
        <td></td>
        <td></td>
        <td><code>more(1, -1) ~~> one(2) :++ labels</code></td>
    </tr>
</table>
<p> In case your custom edge is not labeled you can extend one of the following traits:
</p>
<table>
    <tr>
        <td><strong>Edge type</strong></td>
        <td><strong>Supporting trait in scalax.collections</strong></td>
    </tr>
    <tr>
        <td>directed</td>
        <td><code>generic.AbstractDiEdgeImplicits</code></td>
    </tr>
    <tr>
        <td>undirected</td>
        <td><code>generic.AbstractEdgeImplicits</code></td>
    </tr>
    <tr>
        <td>hyperedge</td>
        <td><code>generic.AbstractHyperEdgeImplicits.FromAny</code><br/>
            <code>generic.AbstractHyperEdgeImplicits.FromEdge</code>
        </td>
    </tr>
    <tr>
        <td>directed hyperedge</td>
        <td><code>generic.AbstractDiHyperEdgeImplicits.FronOneOrMore</code></td>
    </tr>
</table>
<p> Create the implicit conversion to employ a standard infix constructor like
</p>
<pre class="prettyprint lang-scala nolinenum">case class MyDiEdge(source: String, target: String)
    extends AbstractDiEdge(source, target)

implicit final class MyNodeImplicits(val source: String)
    extends AnyVal
    with AbstractDiEdgeImplicits[String, MyDiEdge, MyDiEdge.type] {
  protected def companion = MyDiEdge
}

"ab" ~> "cd" // MyDiEdge("ab", "cd")
</pre>
<p> For your labeled custom edge, reuse the corresponding node operator and define your label conversion operator like
</p>
<pre class="prettyprint lang-scala nolinenum">case class MyLDiEdge(source: String, target: String, n: Int, s: String)
    extends AbstractDiEdge(source, target)

import scalax.collection.edges.DiEdgeImplicits

implicit class MyLDiEdgeInfixLabelConstructor(val e: DiEdge[String]) extends AnyVal {
  def :+(label_1: Int, label_2: String) = MyLDiEdge(e.source, e.target, label_1, label_2)
}

"ab" ~> "cd" :+ (1, "xy") // MyLDiEdge("ab", "cd", 1, "xy")
</pre>

<h3 id="ToString">Override toString</h3>
<p> Whenever you opt for an infix constructor, do not miss the corresponding <code>toString</code> representation.
    This is also facilitated by convenience traits for every edge type like
</p>
<pre class="prettyprint lang-scala nolinenum">case class MyLDiEdge(source: String, target: String, n: Int, s: String)
    extends AbstractDiEdge(source, target)
    with LDiEdgeToString {
  override protected def labelToString: String = s"($n, $s)"
}

("ab" ~> "cd" :+ (1, "xy")).toString // "ab" ~> "cd" :+ (1, "xy")
</pre>
<p> To override the symbol <code>:+</code> by <code>:++</code> for multiedges you should further mix in
    <code>MultiLEdgeToString</code>.
</p>

<h3 id="InfixEdgeExtractors">Add Infix Edge Extractors</h3>
<p> Add more syntactic sugar to get edge patterns shine alike. Here is an example for how it works for the above
    <code>MyLDiEdge</code>:
</p>
<pre class="prettyprint lang-scala nolinenum">type Node = String
type Labels = (Int, String)

object :~> extends UnapplyLabeledEdge[Node, MyLDiEdge, Labels] {
  protected def label(e: MyLDiEdge): Labels = (e.n, e.s)
}
object +: extends UnapplyLabel[Node, Labels]

"ab" ~> "cd" :+ (1, "xy") match {
  case source :~> target +: (num, str) =>
}
</pre>
<p> You might wonder why the position of colons is mixed up in the infix edge extractor symbols.
    Unfortunately this is the only way to get the desired outcome due to operator precedence rules.
    To make the best of it, we recommend using the following infix extractors:
</p>
<table>
    <tr>
        <td><strong>Edge type</strong></td>
        <td><strong>Edge extractor</strong></td>
        <td><strong>Further decompose by</strong></td>
        <td><strong>Label extractor</strong></td>
    </tr>
    <tr>
        <td>directed edge</td>
        <td align="center"><code>:~></code></td>
        <td></td>
        <td align="center"><code>+:</code></td>
    </tr>
    <tr>
        <td>directed multiedge</td>
        <td align="center"><code>:~></code></td>
        <td></td>
        <td align="center"><code>++:</code></td>
    </tr>
    <tr>
        <td>unirected edge</td>
        <td align="center"><code>:~</code></td>
        <td></td>
        <td align="center"><code>+:</code></td>
    </tr>
    <tr>
        <td>undirected multiedge</td>
        <td align="center"><code>:~</code></td>
        <td></td>
        <td align="center"><code>++:</code></td>
    </tr>
    <tr>
        <td>hyperedge</td>
        <td align="center"></td>
        <td align="center"><code>Several.Seq</code></td>
        <td align="center"><code>+:</code></td>
    </tr>
    <tr>
        <td>multi hyperedge</td>
        <td align="center"></td>
        <td align="center"><code>Several.Seq</code></td>
        <td align="center"><code>++:</code></td>
    </tr>
    <tr>
        <td>directed hyperedge</td>
        <td align="center"><code>:~~></code></td>
        <td align="center"><code>OneOrMore.Seq</code></td>
        <td align="center"><code>+:</code></td>
    </tr>
    <tr>
        <td>directed multi hyperedge</td>
        <td align="center"><code>:~~></code></td>
        <td align="center"><code>OneOrMore.Seq</code></td>
        <td align="center"><code>++:</code></td>
    </tr>
</table>
<p> The supporting traits are not specific to edge types unless you have a custom generic edge.</p>

<h2>Populate your Graph</h2>
<pre class="prettyprint lang-scala linenums">val g1 = Graph(3~1, 5)            // Graph[Int,UnDiEdge](1, 3, 5, 3~1)
val g2 = Graph(UnDiEdge(3, 1), 5) // same as above
val gA = Graph(3~>1.2)            // Graph[AnyVal,DiEdge](3, 1.2, 3~>1.2)
val h = Graph(1~1, 1~2~3)         // Graph[Int,HyperEdge](1, 2, 3, 1~1, 1~2~3)
val (jfc, fra, dme) = (Airport("JFC"), Airport("FRA"), Airport("DME"))
val flights = Graph(
	(jfc ~+#> fra)(Flight("LH 400" ,10 o 25, 8 h 20)),
	(fra ~+#> dme)(Flight("LH 1444", 7 o 50, 3 h 10))
val nodes = List(5)
val edges = List(3~1)
val g3 = Graph.from(nodes, edges)
var n, m = 0; val f = Graph.fill(100)( {n = m; m += 1; n~m} ) 
</pre>
<p>As to</p>
<ol>
    <li>Creates an undirected graph of the type <code>Graph[Int,UnDiEdge]
    </code>with the node set <code>{1, 3, 5}</code> and the edge set {3~1}.
        The operator <code>~</code> is used to create undirected edges.
        N is inferred to be <code>Int</code> because both the edge ends
        and the single node are of type <code>Int</code>.
    </li>
    <li>Creates the very same undirected graph as a). Operator <code>~</code>
        is just a short-hand for invoking the factory <code>UnDiEdge</code>.
    </li>
    <li>Creates a directed graph of the type <code>Graph[AnyVal,DiEdge]</code>
        with the node set <code>{3, 1.2}</code> and the edge set {3~&gt;1.2}.
        The operator <code>~&gt;</code> is used to create directed edges.
        N is inferred to be <code>AnyVal</code> because this is the smallest common
        super type of the edge ends.
    </li>
    <li>Creates a hypergraph of the type <code>Graph[Int,HyperEdge]
    </code>with the node set <code>{1, 2, 3}</code> and the edge set {1~1, 1~2~3}.
        In <code>1~2~3</code> the second <code>~</code> operator creates
        an undirected hyperedge because the left operand is already an edge.
    </li>
    <li value="6">Creates an instance of<code> Graph[Airport,LkDiEdge]</code>
        with a node set containing the airports <code>JFC</code>, <code>FRA</code>
        and <code>DME</code> derived from the edge ends and an edge set
        containing two flights. The edges have labels of the type <code>Flight</code>,
        <code>~+#&gt;</code> is an edge factory shortcut to pass the labels.
        The <code>Flight</code> attributes are flight number, departure time
        and flight duration. See also <em>2.3 Edge Factories</em>.
    </li>
    <li value="11">Creates a <code>Graph</code> from the <code>Iterable</code>
        values <code>nodes</code> and <code>edges</code>. This <code>Graph</code>
        instance&nbsp; <code>g3</code> equals to <code>g1</code>.
    </li>
    <li>Creates a <code>Graph</code> instance with 100 edges {0~1, 1~2, ..., 99~100}.
    </li>
</ol>
