---
title: Constrained User Guide
sideMenuItems: >
  <li><a href="#Introduction">Introduction</a></li>
  <li><a href="#UseCases">Use Cases</a></li>
  <li><a href="#Lifecycle">The Constraint Lifecycle</a></li>
  <li><a href="#Altering">Altering Existing Constraints</a></li>
  <li><a href="#Implementing">Implementing New Constraints</a></li>
  <li><a href="#Composing">Composing Constraints</a></li>
  <li><a href="#Aliases">Providing Aliases</a></li>
---

<h1>Constrained User Guide</h1>

<h2 id="Introduction">Introduction</h2>
<p> This module enables the user of <em>Graph for Scala</em> to seamlessly integrate predefined
    or custom constraints. A constraint aims at enforcing any graph properties during the whole lifetime
    of a <code>Graph</code> that are not adequately enforceable by the type system.
    Examples for common constraints are <code>Connected</code>, <code>Acyclic</code>, <code>Tree</code>, <code>Planar</code> etc.
    Based on this module you are free to implement your own custom constraint to cover your domain-specific requirements.
</p>
<p> Predefined constraints are placed in <code>scalax.collection.constrained.constraints</code>.
    We certainly appreciate your contributing any additional constraint that may be of interest to the community.
</p>
<p> To take advantage of constrained <code>Graph</code>s you need to change your <code>import</code> and
    pass any predefined or custom constraint at <code>Graph</code> creation time like:
</p>
<pre class="prettyprint lang-scala linenums">import scalax.collection.GraphPredef._
import scalax.collection.GraphEdge._
import scalax.collection.constrained.mutable.Graph
import scalax.collection.constrained.constraints.Connected

implicit val conf: Config = Connected
val e = Graph(1 ~ 2, 3 ~ 4) // Graph()
val g = Graph(1 ~ 2, 2 ~ 4) // Graph(1, 2, 4, 1~2, 2~4)
g += 3                      // Graph(1, 2, 4, 1~2, 2~4)
g += 2 ~ 3                  // Graph(1, 2, 3, 4, 1~2, 2~3, 2~4)
</pre>
<p>As to</p>
<ol>
    <li value="3">Choosing mutable constrained <code>Graph</code>.
    </li>
    <li value="6">Referring to the predefined constraint <code>Connected</code>.
    </li>
    <li>Creates a connected <code>Graph</code> using the above implicit value.
        <code>e</code> becomes empty because the total of the passed elements violates the constraint.
    </li>
    <li>Creates a connected <code>Graph</code> accepting the passed elements.
    </li>
    <li>Adding <code>3</code> is silently rejected because it would create an isolated node.
    </li>
    <li>Adding <code>2 ~ 3</code> is carried out since the resulting graph remains connected.
    </li>
</ol>
<p> If you are interested in whether or why an operation has been refused, simply call its verbose counterpart.
    These additional methods/operators are denoted by a <code>_?</code>/<code>?</code> suffix
    and return an <code>Either[ConstraintViolation, R]</code>
    with <code>R</code> being the return type of the non-suffixed counterpart method/operation:
</p>
<pre class="prettyprint lang-scala linenums">
val e = Graph.from_?(edges = 1 ~ 2, 3 ~ 4) // Left(...)
val g = Graph.from_?(edges = 1 ~ 2, 2 ~ 4) // Right(Graph(1, 2, 4, 1~2, 2~4))
g += 3                                     // Left(...)
g += 2 ~ 3                                 // Right(Graph(1, 2, 3, 4, 1~2, 2~3, 2~4))
</pre>
<p> Constraints may also be combined by means of the <code>&amp;&amp;</code> and <code>||</code> operators.
</p>
<p> <em id="G4S">Graph for Scala Constrained</em> is supplied as an extra module
    (<code>graph-constrained_&lt;ScalaVer&gt;-&lt;Graph4ScalaVer&gt;.jar</code>).
</p>

<h2 id="UseCases">Use Cases</h2>
<p> Among others, the constrained module is worth considering in the following situations:
</p>
<ol><li>You have to ensure that some constraints which cannot be achieved by type constructors
        are valid at any time for your <code>Graph</code> instances. Typical examples are acyclic graphs
        or tree structures.
    </li>
    <li>In addition to 1., you need to control the population or modification of <code>Graph</code> instances
        that occur in an uncontrolled way such as by
        <ul><li>user input that is not fully validatable with respect to your <code>Graph</code> constraint or</li>
            <li>import of invalidated data from an external source.</li>
        </ul>
    </li>
    <li>You want to log or monitor <code>Graph</code> creation/modification &#8211;
        with respect to being proper or improper.
    </li>
</ol>

<h2 id="Lifecycle">The Constraint Lifecycle</h2>
<p> For the purpose of a comparison, let's first illustrate the "lifecycle" of an operation such as
    <code>+</code> or <code>+=</code> on a non-constrained <code>Graph</code>:
</p>
<figure>
    <img alt="Empty Lifecycle" src="/img/guides/constrained/EmptyLifecycle.jpg">
    <figcaption>Diagram: Trivial Lifecycle of non-constrained <code>Graph</code> operations.</figcaption>
</figure>
<p>In contrast, operations on constrained <code>Graph</code>s have the following sophisticated lifecycle:
</p>
<figure>
    <img alt="Lifecycle" src="/img/guides/constrained/Lifecycle.jpg">
    <figcaption>Diagram: Lifecycle of constrained <code>Graph</code> operations.</figcaption>
</figure>
<p> <em>Pre-check</em> and <em>post-check</em> depict the two groups of callback-methods
    to be defined by the implementer of the constraint. Each group consists of a few concrete methods
    such as <code>preAdd(node: N)</code>, <code>preAdd(edge: E[N])</code> etc.
</p>
<p> The pre-check methods will be called to inspect the underlying <code>Graph</code> and the arguments
    of the operation before the operation takes place. They take control over whether the operation is to be
    performed or aborted (return for the latter <code>Abort</code>).
    In case the pre-check method requests the operation to be performed, it may do so by either
    returning <code>PostCheck</code>) or <code>Complete</code> telling whether post-check is to be called or skipped.
</p>
<p> In the post-check call-back methods one may inspect the underlying <code>Graph</code> as it would be
    after the operation and take control over whether the operation is to be committed (return: <code>Right</code>)
    or rolled back (return: <code>Left</code>).
</p>
<p> Further, you may opt for silent or verbose operations:
    All operations also known in non-constrained graphs will enforce the constraint but won't be responsive
    about whether it was successful or has been rejected. Hence the term silent.
    To retrieve information about success or rejection you need to call a counterpart operation.
    These counterpart operations/methods have the same name plus a <code>?</code>/<code>_?</code>suffix.
    For instance, <code>+=</code> its counterpart <code>+=?</code> do the same but are silent resp. verbose.
</p>

<h2 id="Implementing">Implementing New Constraints</h2>
<p> If none of the supplied constraints suffices your needs you are encouraged to implement your own constraint.
</p>
<p> To warm up, you might contemplate the rather simple predefined constraint <code>Connected.scala</code>
    along with its accompanying test <code>TConnected.scala</code>.
</p>
<p> Constraint implementations involve the following steps:
</p>
<ol>
    <li>Constraint Class
    <ul><li>Create your constraint class extending the <code>Constrained</code> trait.</li>
        <li>Decide on each call-back method, whether abstract or concrete, whether and how to override it:
        <ul><li><code>preCreate</code>'s default implementation calls <code>preAdd</code> for each node and edge.
                This will be insufficient for all cases where the set of these elements must be considered in its total.
                For instance, cycles cannot be detected by examining nodes and edges separately.<br>If it is maintained
                that on loading the <code>Graph</code> it is already consistent, you can simply return
                <code>PreCheckResult(Complete)</code>.</li>
            <li>Implement <code>preAdd(node: N)</code> and <code>preAdd(edge: E[N])</code>. Ensure to make all checks
                possible at this early stage.</li>
            <li>Decide on whether <code>preAdd(elems: GraphParamIn[N,E]*)</code> is to be overridden.
                Here the same holds as for <code>preCreate</code>, as the default implementation just calls
                <code>preAdd</code> element-wise.</li>
            <li>Decide on whether <code>postAdd</code> is to be overridden. If you have made all necessary checks
                in the pre-checks concerned with addition, you need not do anything as <code>postAdd</code>'s
                default return is <code>true</code> which advises Graph to commit the addition.</li>
            <li>Do the same with respect to the call-back methods concerned with subtraction.</li>
            <li>Decide on whether to override any of the error handlers <code>onAdditionRefused</code> or
                <code>onSubtractionRefused</code>. They return <code>true</code> by default meaning that
                operations that abort or roll back will be left without a notice.</li>
       </ul></li>
    </ul>
    </li>
    <li>Constraint Companion Object
    <ul><li>Create your constraint companion object by extending the <code>ConstrainedCompanion</code> trait.
            Ensure that the type constructor argument for <code>ConstrainedCompanion</code> is your custom
            constraint class.</li>
        <li>Override <code>apply</code> in your constraint companion object to return an instance of your
            constraint class.</li>
    </ul></li>
    <li>Constraint Test</li>
</ol>
<p> Although call-backs are designed to be passed all necessary arguments to decide on how to deal
    with the operation, sometimes you might desire to carry over intermediate results computed in a
    pre-check to the corresponding post-check. For this purpose, you just need to subclass <code>Result</code>,
    fill an instance of your type with the computational results and return it in place of a simple
    <code>PreCheckResult</code> instance. Examine <code>scalax.collection.constrained.constraints.
    Acyclic</code> for an example.
</p>
<p> Once again, if you feel the community could benefit of your constraint implementation, please consider
    contributing it.
</p>

<h2 id="Composing">Composing Constraints</h2>
<p> Constraints may be composed by the <code>&amp;&amp;</code> and <code>||</code> operators like:
</p>
<pre class="prettyprint lang-scala nolinenum">implicit val conf: Config = Connected && Acyclic // ConstrainedConfig(...)
val e = Graph.from(nodeList, edgeList)
</pre>

<h2 id="Aliases">Providing Aliases</h2>
<p> By now you know when and how to implement constraints and how to pass them to <code>Graph</code>
    values at instantiation time. You may wonder how to go a step even further by calling the factory
    methods without repeatedly supplying your constraints.
</p>
<p> Suppose you prefer writing
</p>
<pre class="prettyprint lang-scala nolinenum">val t = Tree.from(nodeList, edgeList) // Tree(...)
</pre>
<p> in contrast to the example in 6. Well, you can do this right away because the <code>Tree</code> alias
    is already present in the <code>constrained</code> module. This is how it has been achieved:
</p>
<pre class="prettyprint lang-scala nolinenum">import scalax.collection.GraphEdge._
import scalax.collection.constrained.Graph // immutable

type Tree[N] = Graph[N,UnDiEdge]
object Tree extends CompanionAlias[UnDiEdge](Connected && Acyclic
                                             withStringPrefix "Tree")
</pre>
<p> Obviously, you can provide your own aliases following the above pattern.
</p>
<p> <code>CompanionAlias</code> is a wrapper trait enabling you to easily construct constrained
    <code>Graph</code> companion module aliases. You may use it as long as the edge type of your
    <code>Graph</code> instances is constant. If you are using an edge type other than <code>UnDiEdge</code>,
    such as a labelled edge type in your <code>Tree</code>, you might consider defining your own alias with
    a labelled edge type parameter or simply forego using an alias.
</p>
<p> Finally, <code>withStringPrefix</code> enables you to replace the default <code>Graph</code> prefix
    used by <code>toString</code> with a prefix of you choice.
</p>
